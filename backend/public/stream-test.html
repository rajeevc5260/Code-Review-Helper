<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>AI Code Review Stream</title>
  <style>
    * { box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      margin: 0;
      padding: 20px;
      background: #fafafa;
      color: #1a1a1a;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .header {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    .input-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 16px;
    }

    input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    input[type="url"] { flex: 1; min-width: 300px; }
    input[type="text"] { min-width: 160px; }
    input[placeholder="message"] { flex: 2; min-width: 200px; }

    button {
      padding: 8px 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    button:hover { background: #f5f5f5; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .primary { background: #007bff; color: white; border-color: #007bff; }
    .primary:hover { background: #0056b3; }

    .stream-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .stream-header {
      padding: 16px 20px;
      border-bottom: 1px solid #eee;
      background: #f8f9fa;
      font-weight: 600;
    }

    .events {
      max-height: 70vh;
      overflow-y: auto;
      padding: 0;
    }

    .event {
      padding: 16px 20px;
      border-bottom: 1px solid #f0f0f0;
      transition: background 0.2s;
    }

    .event:last-child { border-bottom: none; }
    .event.new { background: #f8f9ff; }
    
    .event.pending {
      opacity: 0;
      transform: translateY(10px);
    }
    
    .event.fade-in {
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.4s ease-out, transform 0.4s ease-out;
    }

    .event-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }

    .event-type {
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 12px;
      background: #e9ecef;
      color: #495057;
      font-weight: 500;
    }

    .event-type.analysis-result {
      background: #d4edda;
      color: #155724;
    }

    .event-time {
      font-size: 12px;
      color: #6c757d;
    }

    .event-message {
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 8px;
    }

    .event-details {
      font-size: 12px;
      color: #6c757d;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      background: #f8f9fa;
      padding: 8px 12px;
      border-radius: 4px;
      margin-top: 8px;
    }

    .analysis-summary {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      padding: 16px;
      margin-top: 12px;
      display: none;
      opacity: 0;
    }

    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }

    .stat-item {
      background: white;
      padding: 12px;
      border-radius: 4px;
      border: 1px solid #dee2e6;
      text-align: center;
    }

    .stat-value {
      font-size: 20px;
      font-weight: 600;
      color: #495057;
    }

    .stat-label {
      font-size: 12px;
      color: #6c757d;
      margin-top: 4px;
    }

    .files-list {
      margin-top: 16px;
    }

    .files-header {
      font-weight: 600;
      margin-bottom: 8px;
      color: #495057;
      font-size: 14px;
    }

    .file-item {
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 8px;
    }

    .file-name {
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-weight: 600;
      color: #495057;
      font-size: 13px;
    }

    .file-meta {
      font-size: 11px;
      color: #6c757d;
      margin-top: 4px;
    }

    .thinking {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #6c757d;
      font-style: italic;
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #e9ecef;
      border-top: 2px solid #6c757d;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .status-active { color: #28a745; }
    .status-error { color: #dc3545; }
    .status-complete { color: #6c757d; }

    .markdown {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 4px;
      padding: 16px;
      margin-top: 8px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 13px;
      line-height: 1.5;
      white-space: pre-wrap;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #6c757d;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      margin-left: auto;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #dc3545;
    }

    .status-dot.connected { background: #28a745; }
    .status-dot.connecting { background: #ffc107; }

    .truncation-badge {
      display: inline-block;
      background: #fff3cd;
      color: #856404;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 style="margin: 0 0 16px 0; font-size: 24px; font-weight: 600;">AI Code Review Stream</h1>
      
      <div>
        <label style="display: block; margin-bottom: 4px; font-size: 14px; font-weight: 500;">API Endpoint</label>
        <input type="url" id="url" value="http://localhost:3010/ai/review/stream">
      </div>

      <div class="input-row">
        <input type="text" id="userId" placeholder="User ID" value="f81d4fae-7dec-11d0-a765-00a0c91e6bf6">
        <input type="text" id="zipFileId" placeholder="Zip File ID" value="123e4567-e89b-12d3-a456-426614174000">
        <input type="text" id="message" placeholder="Analysis request message" value="Scan routes and identify potential issues">
        <button id="start" class="primary">Start Analysis</button>
        <button id="stop">Stop</button>
        <button id="clear">Clear</button>
      </div>
    </div>

    <div class="stream-container">
      <div class="stream-header">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <span>Analysis Stream</span>
          <div class="connection-status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Disconnected</span>
          </div>
        </div>
      </div>
      
      <div class="events" id="events">
        <div class="empty-state">
          <p>Click "Start Analysis" to begin streaming AI code review</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    let controller;
    let eventCount = 0;
    let isThinking = false;
    let eventQueue = [];
    let isProcessingQueue = false;

    const eventsContainer = document.getElementById('events');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');

    function updateConnectionStatus(status) {
      statusDot.className = `status-dot ${status}`;
      switch(status) {
        case 'connected':
          statusText.textContent = 'Connected';
          break;
        case 'connecting':
          statusText.textContent = 'Connecting...';
          break;
        default:
          statusText.textContent = 'Disconnected';
      }
    }

    function formatTime(timestamp) {
      return new Date(timestamp || Date.now()).toLocaleTimeString();
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function createAnalysisSummary(data) {
      const { totalOperations, filesAnalyzed, responseLength, analyzedFiles } = data;
      
      return `
        <div class="analysis-summary">
          
          
          ${analyzedFiles && analyzedFiles.length > 0 ? `
            <div class="files-list">
              <div class="files-header">Analyzed Files</div>
              ${analyzedFiles.map(file => `
                <div class="file-item">
                  <div class="file-name">${file.fileName}</div>
                  <div class="file-meta">
                    Size: ${formatFileSize(file.fileSizeBytes)}
                    ${file.contentTruncated ? '<span class="truncation-badge">Truncated</span>' : ''}
                  </div>
                </div>
              `).join('')}
            </div>
          ` : ''}
        </div>
      `;
    }

    async function processEventQueue() {
      if (isProcessingQueue || eventQueue.length === 0) return;
      
      isProcessingQueue = true;
      
      while (eventQueue.length > 0) {
        const { type, data } = eventQueue.shift();
        await addEventToDOM(type, data);
        // Add delay between events for smooth appearance
        await new Promise(resolve => setTimeout(resolve, 300));
      }
      
      isProcessingQueue = false;
    }

    function addEvent(type, data) {
      eventQueue.push({ type, data });
      processEventQueue();
    }

    async function addEventToDOM(type, data) {
      return new Promise(resolve => {
        if (eventCount === 0) {
          eventsContainer.innerHTML = '';
        }

        const eventDiv = document.createElement('div');
        eventDiv.className = 'event pending';
        eventDiv.id = `event-${eventCount++}`;

        // Remove thinking indicator if present
        if (isThinking) {
          const thinkingEl = document.querySelector('.thinking');
          if (thinkingEl) thinkingEl.remove();
          isThinking = false;
        }

        let messageContent = '';
        let eventTypeClass = type === 'analysis_result' ? 'analysis-result' : '';

        if (type === 'analysis_result') {
          // Special handling for analysis_result - show all data in nice format
          messageContent = `
            <div class="event-message">Analysis completed successfully</div>
            ${data.message ? `<div class="markdown">${data.message}</div>` : ''}
            ${createAnalysisSummary(data)}
          `;
        } else {
          // For all other events, only show the message content cleanly
          const message = data.message || data.status || 'Event received';
          messageContent = `<div class="event-message">${message}</div>`;
        }

        eventDiv.innerHTML = `
          <div class="event-header">
            <span class="event-type ${eventTypeClass}">${type}</span>
            <span class="event-time">${formatTime(data.timestamp)}</span>
          </div>
          ${messageContent}
        `;

        eventsContainer.appendChild(eventDiv);

        // Trigger fade-in effect with a slight delay
        setTimeout(() => {
          eventDiv.classList.remove('pending');
          eventDiv.classList.add('fade-in', 'new');
          eventDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 50);

        // Remove 'new' class after background animation
        setTimeout(() => {
          eventDiv.classList.remove('new');
          resolve();
        }, 600);

        // Add thinking indicator for processing events
        if (shouldShowThinking(type)) {
          addThinkingIndicator();
        }
      });
    }

    function shouldShowThinking(eventType) {
      const thinkingEvents = [
        'start', 'progress', 'directory_scan_started', 
        'file_access_started', 'file_analysis_started'
      ];
      return thinkingEvents.includes(eventType);
    }

    function addThinkingIndicator() {
      if (isThinking) return;
      
      const thinkingDiv = document.createElement('div');
      thinkingDiv.className = 'event thinking';
      thinkingDiv.innerHTML = `
        <div class="event-header">
          <div class="spinner"></div>
          <span>Processing...</span>
        </div>
      `;
      
      eventsContainer.appendChild(thinkingDiv);
      thinkingDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
      isThinking = true;
    }

    function parseSSELine(line) {
      if (line.startsWith('event: ')) {
        return { type: 'event', value: line.slice(7).trim() };
      }
      if (line.startsWith('data: ')) {
        return { type: 'data', value: line.slice(6).trim() };
      }
      if (line.startsWith(': ')) {
        return { type: 'comment', value: line.slice(2) };
      }
      return null;
    }

    document.getElementById('start').onclick = async () => {
      if (controller) controller.abort();
      controller = new AbortController();

      const url = document.getElementById('url').value.trim();
      const userId = document.getElementById('userId').value.trim();
      const zipFileId = document.getElementById('zipFileId').value.trim();
      const message = document.getElementById('message').value.trim();

      if (!url || !userId || !zipFileId || !message) {
        alert('Please fill in all fields');
        return;
      }

      updateConnectionStatus('connecting');
      eventCount = 0;

      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId, zipFileId, message }),
          signal: controller.signal
        });

        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }

        if (!res.body) {
          throw new Error('No response body');
        }

        updateConnectionStatus('connected');

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let currentEvent = null;
        let currentData = null;

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            const parsed = parseSSELine(line);
            
            if (parsed?.type === 'event') {
              currentEvent = parsed.value;
            } else if (parsed?.type === 'data') {
              try {
                currentData = JSON.parse(parsed.value);
              } catch {
                currentData = { message: parsed.value };
              }
            } else if (line === '' && currentEvent && currentData) {
              addEvent(currentEvent, currentData);
              currentEvent = null;
              currentData = null;
            }
          }
        }

        updateConnectionStatus('disconnected');
      } catch (error) {
        updateConnectionStatus('disconnected');
        if (error.name !== 'AbortError') {
          addEvent('error', { 
            message: `Connection failed: ${error.message}`,
            timestamp: Date.now()
          });
        }
      }
    };

    document.getElementById('stop').onclick = () => {
      if (controller) {
        controller.abort();
        updateConnectionStatus('disconnected');
        if (isThinking) {
          const thinkingEl = document.querySelector('.thinking');
          if (thinkingEl) thinkingEl.remove();
          isThinking = false;
        }
      }
    };

    document.getElementById('clear').onclick = () => {
      eventsContainer.innerHTML = '<div class="empty-state"><p>Click "Start Analysis" to begin streaming AI code review</p></div>';
      eventCount = 0;
      isThinking = false;
      eventQueue = [];
      isProcessingQueue = false;
    };

    // Handle keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.metaKey || e.ctrlKey) {
        if (e.key === 'Enter') {
          e.preventDefault();
          document.getElementById('start').click();
        } else if (e.key === '.') {
          e.preventDefault();
          document.getElementById('stop').click();
        }
      }
    });
  </script>
</body>
</html>